<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COSMIC CHAOS - Target Destruction Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial Bltargetack', sans-serif;
            background: #000;
            overflow: hidden;
            cursor: none;
        }
        
        #setupScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(12px) saturate(1.3);
            background: linear-gradient(135deg,rgba(26,26,46,0.92),rgba(16,33,62,0.92),rgba(15,52,96,0.92));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        
        .setup-container {
            background: rgba(30,30,40,0.7);
            border-radius: 36px;
            box-shadow: 0 8px 48px 0 #ff6b6b, 0 2px 24px 0 #222 inset;
            border: 2.5px solid #fff3;
            padding: 48px 24px 36px 24px;
            max-width: 420px;
            width: 96vw;
            margin: 0 auto;
            position: relative;
            transition: box-shadow 0.3s;
            animation: fadeIn 0.7s;
        }
        
        .setup-container h1 {
            font-size: 2.2rem;
            margin-bottom: 18px;
            color: #ff6b6b;
            text-shadow: 0 0 24px #ff6b6b, 0 0 8px #fff;
            letter-spacing: 2px;
        }
        
        .setup-container p {
            font-size: 16px;
            margin-bottom: 30px;
            color: #ccc;
        }
        
        #opponentSelect h2 {
            font-size: 1.2rem;
            color: #fff;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        #opponentBtns button.control-btn {
            border-radius: 28px;
            font-size: 1.15rem;
            padding: 14px 32px;
            background: linear-gradient(45deg,#232526,#414345);
            border: 2.5px solid #ff6b6b;
            color: #fff;
            box-shadow: 0 0 0 #ff6b6b;
            transition: all 0.22s;
            outline: none;
            position: relative;
            overflow: hidden;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        #opponentBtns button.control-btn.selected,
        #opponentBtns button.control-btn:active,
        #opponentNext.control-btn,
        #startGame,
        #gunBtn,
        #rageBtn {
            background: #ff6b6b;
            color: #fff;
            box-shadow: 0 0 24px #ff6b6b,0 0 8px #fff;
        }
        #gunBtn { background: #1e90ff; }
        #rageBtn { background: #ffe066; color: #b30000; }
        #opponentBtns button.control-btn:hover,
        #opponentNext.control-btn:hover,
        #startGame:hover {
            box-shadow: 0 0 48px #ff6b6b,0 0 16px #fff;
            filter: brightness(1.13);
        }
        @media (max-width: 600px) {
            .setup-container, .hud, .controls, #opponentBtns button, #opponentNext, #startGame, #gunBtn, #rageBtn {
                font-size: 1rem;
                padding: 10px 8vw;
                width: 98vw;
                max-width: 99vw;
                margin: 6px auto;
            }
            #opponentBtns {
                flex-wrap: wrap;
                justify-content: center;
                gap: 12px;
            }
            .hud { flex-direction: column; align-items: center; left: 0; right: 0; top: 8px; }
            .multi-hit-counter { right: 8px; top: 60px; bottom: unset; }
            .rage-meter { right: 8px; top: 20px; bottom: unset; }
            #nameInput {
                height: 100px;
                font-size: 1rem;
                padding: 12px;
            }
            #gameGuide {
                font-size: 0.95rem;
                padding: 18px 15px 12px 15px;
            }
        }
        
        #gameGuide {
            background: rgba(30,30,40,0.85);
            border-radius: 22px;
            box-shadow: 0 0 32px #4ecdc4,0 0 12px #fff;
            color: #ffdada;
            margin-bottom: 18px;
            padding: 22px 18px 16px 18px;
            font-size: 1.08rem;
            line-height: 1.8;
            border: 2px solid #4ecdc4;
            animation: fadeIn 0.7s;
        }
        
        #nameInputTip {
            color: #ff6b6b;
            font-size: 1.12rem;
            margin-bottom: 10px;
            letter-spacing: 1px;
        }
        
        #nameInput {
            width: 100%;
            height: 120px;
            background: rgba(255,255,255,0.10);
            border: 2.5px solid #4ecdc4;
            border-radius: 16px;
            color: #fff;
            font-size: 1.12rem;
            padding: 16px;
            resize: none;
            margin-bottom: 18px;
            box-shadow: 0 0 16px #4ecdc4 inset;
            transition: border 0.2s,box-shadow 0.2s;
        }
        
        #nameInput:focus {
            border: 2.5px solid #ff6b6b;
            box-shadow: 0 0 32px #ff6b6b;
            outline: none;
        }
        
        #startGame {
            padding: 16px 44px;
            background: #ff6b6b; color: #fff;
            border: none;
            border-radius: 28px;
            font-weight: bold;
            font-size: 1.18rem;
            cursor: pointer;
            transition: all 0.22s;
            box-shadow: 0 0 32px #4ecdc4,0 0 12px #fff;
            margin-top: 10px;
        }
        
        #startGame:hover {
            transform: scale(1.09);
            box-shadow: 0 0 60px #ff6b6b,0 0 20px #fff;
        }
        
        #gameCanvas {
            display: none;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%);
            cursor: none;
        }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            z-index: 1000;
            pointer-events: none;
        }
        
        .hud-item {
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid #ff6b6b;
            box-shadow: 0 0 20px #ff6b6b;
            animation: hudGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes hudGlow {
            0% { box-shadow: 0 0 20px #ff6b6b; }
            100% { box-shadow: 0 0 40px #ff6b6b, 0 0 60px #ff6b6b; }
        }
        
        .power-meter {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 300px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4ecdc4;
            border-radius: 10px;
            z-index: 1000;
        }
        
        .power-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #4ecdc4, #45b7d1, #6c5ce7, #fd79a8);
            border-radius: 8px;
            transition: height 0.1s ease;
        }
        
        .crosshair {
            position: fixed;
            pointer-events: none;
            z-index: 999;
            width: 40px;
            height: 40px;
            border: 3px solid #ff6b6b;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #ff6b6b;
            animation: crosshairPulse 1s ease-in-out infinite;
        }
        
        @keyframes crosshairPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }
        
        .destruction-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 20px #ff6b6b;
            pointer-events: none;
            z-index: 998;
            opacity: 0;
            animation: explosionText 2s ease-out;
        }
        
        @keyframes explosionText {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0) rotate(-180deg); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5) rotate(0deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1) rotate(180deg); }
        }
        
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
        }
        
        .control-btn {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            color: white;
            border: none;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }
        
        .control-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.8);
        }
        
        .shake {
            animation: screenShake 0.8s ease-in-out;
        }
        
        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-8px); }
            20% { transform: translateX(8px); }
            30% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            50% { transform: translateX(-8px); }
            60% { transform: translateX(8px); }
            70% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
            90% { transform: translateX(-8px); }
        }
        
        /* æ…¢åŠ¨ä½œæ•ˆæœ */
        .slow-motion * {
            animation-duration: calc(var(--slow-speed, 1) * 1s) !important;
            transition-duration: calc(var(--slow-speed, 1) * 1s) !important;
        }
        
        .rage-meter {
            position: fixed;
            top: 20px;
            right: 240px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .rage-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(to right, #ff6b6b, #4ecdc4);
            transition: width 0.1s ease;
        }
        
        .multi-hit-counter {
            position: fixed;
            top: 60px;
            right: 20px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }
        
        .red-rage {
            filter: hue-rotate(-20deg) brightness(1.1) saturate(1.8) drop-shadow(0 0 40px #ff1e1e);
            background: #2d0000 !important;
        }
        
        @keyframes flashCombo {
            0% { box-shadow: 0 0 20px #ff6b6b; color: #fff; }
            100% { box-shadow: 0 0 40px #fff; color: #ff6b6b; }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* é©¬æ¥è¥¿äºšé£æ ¼è‰²å½©ä¸æ°”æ³¡ç¾åŒ– */
        .dialog-bubble {
            min-width: 200px;
            max-width: 340px;
            min-height: 54px;
            background: linear-gradient(135deg,rgba(255,255,255,0.97) 80%,#ffe066 100%);
            border-radius: 28px 28px 36px 36px;
            box-shadow: 0 6px 36px #ff6b6b,0 0 12px #ffe066,0 0 8px #fff;
            border: 2.5px solid #1e90ff;
            color: #222;
            font-size: 1.32rem;
            font-family: 'Arial Black',sans-serif;
            font-weight: bold;
            line-height: 1.8;
            padding: 22px 20px 18px 20px;
            text-align: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%) scale(1);
            z-index: 1002;
            animation: fadeIn 0.5s, bubblePop 0.5s;
            overflow-y: auto;
            word-break: break-all;
            pointer-events: none;
            border-bottom: 5px solid #ffe066;
        }
        @keyframes bubblePop {
            0% { transform: translateX(-50%) scale(0.7); }
            60% { transform: translateX(-50%) scale(1.12); }
            100% { transform: translateX(-50%) scale(1); }
        }
    </style>
</head>
<body>
    <div id="setupScreen">
        <div class="setup-container">
            <h1>ğŸ¯ TARGET DESTRUCTION SIMULATOR</h1>
            <div id="playerTypeSelect" style="margin-bottom:24px;">
                <h2>è¯·é€‰æ‹©ä½ çš„èº«ä»½ï¼š</h2>
                <div style="display:flex;gap:16px;justify-content:center;">
                    <button class="control-btn" data-player="student">å¤§å­¦ç”Ÿ</button>
                    <button class="control-btn" data-player="worker">ä¸Šç­æ—</button>
                </div>
            </div>
            <div id="opponentSelect" style="margin-bottom:24px;display:none;">
                <h2>è¯·é€‰æ‹©å¯¹æ‰‹ç±»å‹ï¼ˆå¯å¤šé€‰ï¼‰ï¼š</h2>
                <div id="opponentBtns" style="display:flex;gap:16px;justify-content:center;"></div>
                <button id="opponentNext" class="control-btn" style="margin-top:18px;">ä¸‹ä¸€æ­¥</button>
            </div>
            <div id="gameGuide" style="text-align:left;font-size:15px;color:#ffdada;background:rgba(0,0,0,0.5);padding:16px;border-radius:12px;margin-bottom:18px;display:none;">
                <strong>ç©æ³•è¯´æ˜ï¼š</strong><br>
                - é€‰æ‹©å¯¹æ‰‹ç±»å‹åï¼Œè¾“å…¥å¤šä¸ªåå­—ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ï¼Œç‚¹å‡»å¼€å§‹ã€‚<br>
                - é¼ æ ‡å·¦é”®ï¼šåŸºç¡€æ”»å‡»ã€‚<br>
                - é¼ æ ‡å³é”®ï¼šæ•£å¼¹æ”»å‡»ï¼ˆ5å‘ï¼‰ã€‚<br>
                - é¼ æ ‡åŒå‡»ï¼šè¶…çº§çˆ†ç‚¸ã€‚<br>
                - å‡»ä¸­ç›®æ ‡å¢åŠ æ„¤æ€’å€¼ï¼Œæ„¤æ€’æ»¡å¯å¼€å¯æ„¤æ€’æ¨¡å¼ï¼ˆå­å¼¹å¨åŠ›ç¿»å€ã€çˆ†ç‚¸æ›´çŒ›ã€è‡ªåŠ¨å¤šå‘ï¼‰ã€‚<br>
                - æœºå…³æªæ¨¡å¼ï¼šè‡ªåŠ¨ç–¯ç‹‚æ‰«å°„ã€‚<br>
                - è¿å‡»è®¡æ•°å™¨ï¼šè¿ç»­å‡»ä¸­æ˜¾ç¤ºè¿å‡»æ•°ï¼Œè¿å‡»é«˜ç²’å­æ›´å£®è§‚ã€‚<br>
                - ä¸åŒå¯¹æ‰‹æœ‰ä¸åŒå°è¯å’Œè¡Œä¸ºï¼Œå‰ä»»ä¼šè¿½ä½ ï¼Œè€æ¿æ›´éš¾æ‰“ã€‚<br>
                - ç›®æ ‡è¢«å‡»ä¸­ä¼šè¯´è¯ï¼Œæ­»äº¡æœ‰æ¯ç­å°è¯ã€‚<br>
                - å³ä¾§æœ‰æ€’æ°”æ§½å’Œè¿å‡»æ˜¾ç¤ºã€‚<br>
            </div>
            <p id="nameInputTip" style="display:none;">è¯·è¾“å…¥å¯¹æ‰‹åå­—ï¼ˆæ¯è¡Œä¸€ä¸ªï¼‰ï¼š</p>
            <textarea id="nameInput" style="display:none;" placeholder=""></textarea>
            <button id="startGame" style="display:none;" onclick="startGame()">ğŸš€ BEGIN DESTRUCTION</button>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud">
        <div class="hud-item" id="score">ğŸŒŸ DESTRUCTION SCORE: 0</div>
        <div class="hud-item" id="combo">ğŸ’¥ COMBO: x1</div>
        <div class="hud-item" id="targets">ğŸ¯ TARGETS: 0</div>
    </div>
    
    <div class="crosshair" id="crosshair"></div>
    
    <div class="controls">
        <button class="control-btn" onclick="spawnTargetWave()">ğŸ¯ TARGET WAVE</button>
        <button class="control-btn" onclick="createBlackHole()">ğŸ•³ï¸ BLACK HOLE</button>
        <button class="control-btn" onclick="triggerMegaBlast()">ğŸ’¥ MEGA BLAST</button>
        <button class="control-btn" onclick="resetSimulation()">ğŸ”„ NEW SIMULATION</button>
    </div>

    <div class="rage-meter">
        <div class="rage-fill" id="rageFill"></div>
    </div>
    <div class="multi-hit-counter" id="multiHitCounter" style="display:none;">è¿å‡»ï¼š0</div>

    <div style="position:fixed; right:20px; bottom:20px; z-index:2001; display:flex; flex-direction:column; gap:16px;">
        <button id="rageBtn" class="control-btn" style="background:linear-gradient(45deg,#ff6b6b,#ff1e1e);">ğŸ˜¡ æ„¤æ€’æ¨¡å¼</button>
        <button id="gunBtn" class="control-btn" style="background:linear-gradient(45deg,#4ecdc4,#1e90ff);">ğŸ”« æœºå…³æªæ¨¡å¼</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let targetNames = [];
        let usedNames = [];
        
        const gameState = {
            score: 0,
            combo: 1,
            isCharging: false,
            mouseX: 0,
            mouseY: 0,
            targets: [],
            projectiles: [],
            particles: [],
            blackHoles: [],
            explosions: [],
            stars: [],
            isPlaying: false,
            spaceDebris: [],
            ufos: [],
            planets: [],
            powerUps: {
                shield: false,
                speed: false
            },
            rage: 0,
            multiHitCount: 0,
            multiHitTimer: 0,
            isRageMode: false,
            rageModeTimer: 0,
            isGunMode: false,
            gunModeTimer: 0,
            gunModeFireCD: 0,
            isFiring: false,
            fireInterval: null
        };
        
        function startGame() {
            const input = document.getElementById('nameInput').value.trim();
            if (!input) {
                alert('Please enter at least one target name!');
                return;
            }
            
            targetNames = input.split('\n').filter(name => name.trim()).map(name => name.trim());
            usedNames = [];
            
            if (targetNames.length === 0) {
                alert('Please enter valid target names!');
                return;
            }
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.body.style.cursor = 'none';
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            initializeGame();
            gameState.isPlaying = true;
            gameLoop();
        }
        
        function initializeGame() {
            // Initialize starfield
            gameState.stars = [];
            for (let i = 0; i < 200; i++) {
                gameState.stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    twinkle: Math.random() * Math.PI * 2
                });
            }
            
            // Spawn initial targets
            for (let i = 0; i < Math.min(10, targetNames.length); i++) {
                spawnNamedTarget();
            }
        }
        
        class Target {
            constructor(x, y, size, color, name, velocity = {x: 0, y: 0}) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.name = name;
                this.velocity = velocity;
                this.type = this.determineType(name);
                this.health = this.getInitialHealth();
                this.shape = Target.randomShape();
                this.rotation = 0;
                this.nameOffset = 0;
                this.dialogQueue = [];
                this.dialogBubble = null;
                this.dialogTimer = 0;
                this.hitTimer = 0;
                this.hitColor = '#ffffff';
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 20;

                ctx.beginPath();
                switch (this.shape) {
                    case 'circle':
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        break;
                    case 'square':
                        ctx.rect(-this.size / 2, -this.size / 2, this.size, this.size);
                        break;
                    case 'triangle':
                        ctx.moveTo(0, -this.size / 2);
                        ctx.lineTo(this.size / 2, this.size / 2);
                        ctx.lineTo(-this.size / 2, this.size / 2);
                        ctx.closePath();
                        break;
                    case 'hex':
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3);
                            ctx.lineTo(this.size / 2 * Math.cos(angle), this.size / 2 * Math.sin(angle));
                        }
                        ctx.closePath();
                        break;
                    case 'star':
                        const outerRadius = this.size / 2;
                        const innerRadius = outerRadius / 2.5;
                        for (let i = 0; i < 5; i++) {
                            ctx.lineTo(outerRadius * Math.cos(i * Math.PI / 2.5), outerRadius * Math.sin(i * Math.PI / 2.5));
                            ctx.lineTo(innerRadius * Math.cos((i + 0.5) * Math.PI / 2.5), innerRadius * Math.sin((i + 0.5) * Math.PI / 2.5));
                        }
                        ctx.closePath();
                        break;
                    case 'pentagon':
                        for (let i = 0; i < 5; i++) {
                            const angle = (i * Math.PI * 2 / 5) - Math.PI / 10; // Adjust for upright pentagon
                            ctx.lineTo(this.size / 2 * Math.cos(angle), this.size / 2 * Math.sin(angle));
                        }
                        ctx.closePath();
                        break;
                }
                ctx.fill();
                ctx.restore();

                // Draw the name
                ctx.save();
                ctx.fillStyle = 'white';
                ctx.font = `bold 28px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x, this.y + (this.size / 10));
                ctx.restore();
            }           

            static randomShape() {
                const shapes = ['circle', 'square', 'triangle', 'hex', 'star', 'pentagon'];
                return shapes[Math.floor(Math.random() * shapes.length)];
            }
            
            determineType(name) {
                const lowerName = name.toLowerCase();
                if (lowerName.includes('è€å¸ˆ') || lowerName.includes('teacher')) return 'teacher';
                if (lowerName.includes('å­¦éœ¸') || lowerName.includes('topstudent')) return 'topstudent';
                if (lowerName.includes('ä½œä¸š') || lowerName.includes('homework')) return 'homework';
                if (lowerName.includes('è€ƒè¯•') || lowerName.includes('exam')) return 'exam';
                if (lowerName.includes('è®ºæ–‡') || lowerName.includes('paper')) return 'paper';
                if (lowerName.includes('å®¶é•¿') || lowerName.includes('parent')) return 'parent';
                if (lowerName.includes('hr')) return 'hr';
                if (lowerName.includes('ç”²æ–¹') || lowerName.includes('client')) return 'client';
                if (lowerName.includes('ppt')) return 'ppt';
                if (lowerName.includes('kpi')) return 'kpi';
                if (lowerName.includes('ä¼šè®®') || lowerName.includes('meeting')) return 'meeting';
                if (lowerName.includes('å·¥ä½') || lowerName.includes('desk')) return 'desk';
                if (lowerName.includes('è€ƒå‹¤æœº') || lowerName.includes('clock')) return 'clock';
                if (lowerName.includes('å®¢æˆ·') || lowerName.includes('customer')) return 'customer';
                if (lowerName.includes('è€æ¿') || lowerName.includes('boss')) return 'boss';
                if (lowerName.includes('åŒäº‹') || lowerName.includes('coworker')) return 'coworker';
                if (lowerName.includes('æœ€è®¨åŒçš„å¯¹è±¡') || lowerName.includes('most hated')) return 'mostHated';
                return 'normal';
            }
            
            getInitialHealth() {
                switch(this.type) {
                    case 'boss': return this.size * 3;
                    case 'coworker': return this.size * 1.5;
                    case 'star': return this.size * 5;
                    case 'pentagon': return this.size * 5;
                    case 'mostHated': return this.size * 10;
                    default: return this.size;
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                this.showDialog();
                this.hitTimer = 0.5;
                this.hitColor = '#ffffff';
                gameState.rage = Math.min(100, gameState.rage + 8);
                gameState.multiHitCount++;
                gameState.multiHitTimer = 2;
                document.getElementById('multiHitCounter').style.display = 'block';
                document.getElementById('multiHitCounter').textContent = `è¿å‡»ï¼š${gameState.multiHitCount}`;
            }
            
            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.rotation += 0.02;
                this.nameOffset = Math.sin(Date.now() * 0.005) * 5;
                
                if (this.x < this.size/2 || this.x > canvas.width - this.size/2) {
                    this.velocity.x *= -0.8;
                    this.x = Math.max(this.size/2, Math.min(canvas.width - this.size/2, this.x));
                }
                if (this.y < this.size/2 || this.y > canvas.height - this.size/2) {
                    this.velocity.y *= -0.8;
                    this.y = Math.max(this.size/2, Math.min(canvas.height - this.size/2, this.y));
                }
                
                this.velocity.x *= 0.999;
                this.velocity.y *= 0.999;
                
                switch(this.type) {
                    case 'ex':
                        const dx = gameState.mouseX - this.x;
                        const dy = gameState.mouseY - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > 30) {
                            this.velocity.x += (dx / dist) * 0.18;
                            this.velocity.y += (dy / dist) * 0.18;
                        }
                        break;
                }
                
                if (this.dialogQueue && this.dialogQueue.length) {
                    this.dialogQueue.forEach(d=>d.timer-=0.016);
                    while(this.dialogQueue.length && this.dialogQueue[0].timer<=0) this.dialogQueue.shift();
                    this.dialogBubble = this.dialogQueue.map(d=>d.text).join('\n');
                    if (!this.dialogQueue.length) this.dialogBubble = null;
                }
                
                if (this.hitTimer > 0) {
                    this.hitTimer -= 0.016;
                }
            }
            
            showDialog(isDeath) {
                const dialogs = {
                    teacher: isDeath ? ["è€å¸ˆï¼šä¸‹æ¬¡è®°å¾—äº¤ä½œä¸šï¼(æ¶ˆå¤±)", "è€å¸ˆï¼šä½ è¿™æ¬¡è€ƒå¾—ä¸é”™ï¼Œä¸‹æ¬¡æ›´éš¾ï¼", "è€å¸ˆï¼šæ”¾å­¦åˆ«èµ°ï¼"] : ["ä½œä¸šäº¤äº†å—ï¼Ÿ", "è€ƒè¯•å‘¨è¦æ¥äº†ï¼", "ä½ åˆè¿Ÿåˆ°äº†ï¼", "ä¸‹è¯¾åˆ«èµ°ï¼Œæ¥åŠå…¬å®¤ä¸€è¶Ÿã€‚", "è¿™é¢˜ä¼šä¸ä¼šï¼Ÿ", "ä»Šæ™šè®°å¾—å¤ä¹ ï¼", "Aduh, so many homework lah!", "è¡¥ä¹ ç­ç­‰ä½ å’¯ï¼"],
                    topstudent: isDeath ? ["å­¦éœ¸ï¼šä½ èµ¢äº†æˆ‘ï¼Ÿä¸ç§‘å­¦ï¼", "å­¦éœ¸ï¼šä¸‹æ¬¡å†æ¥PKï¼"] : ["è¿™é¢˜å¾ˆç®€å•å•¦~", "ä½ è¦ä¸è¦æŠ„æˆ‘çš„ï¼Ÿ", "æˆ‘å·²ç»å¤ä¹ ä¸‰éäº†ã€‚", "è€ƒè¯•ç¨³A+ï¼", "ä½ æ˜¨æ™šå¤ä¹ äº†å—ï¼Ÿ", "Geng lahä½ ï¼"],
                    homework: isDeath ? ["ä½œä¸šï¼šç»ˆäºä¸ç”¨å†™æˆ‘äº†ï¼", "ä½œä¸šï¼šä¸‹æ¬¡è¿˜ä¼šæœ‰çš„ï¼"] : ["ä»Šæ™šè¦äº¤å“¦ï¼", "è€å¸ˆåœ¨å‚¬äº†ï¼", "ä½ æ˜¯ä¸æ˜¯åˆå¿˜äº†ï¼Ÿ", "å†™ä¸å®Œå°±åˆ«ç¡è§‰ï¼", "Deadlineåˆ°å’¯ï¼"],
                    exam: isDeath ? ["è€ƒè¯•ï¼šä½ èµ¢äº†è¿™æ¬¡ï¼Œä¸‹æ¬¡è§ï¼", "è€ƒè¯•ï¼šä¸‹å­¦æœŸå†æ¥ï¼"] : ["è€ƒè¯•å‘¨è¦æ¥äº†ï¼Œå‡†å¤‡å¥½äº†å—ï¼Ÿ", "è¿™é¢˜é€åˆ†å•¦ï¼", "ä½ ä¼šä¸ä¼šï¼Ÿ", "è€ƒåœºè§ï¼", "Aduh, so stress lah!"],
                    paper: isDeath ? ["è®ºæ–‡ï¼šæˆ‘ä¼šå›æ¥çš„ï¼", "è®ºæ–‡ï¼šæŸ¥é‡ä¸è¿‡é‡å†™ï¼"] : ["æŸ¥é‡è¿‡äº†å—ï¼Ÿ", "æ ¼å¼æ”¹äº†å—ï¼Ÿ", "å¯¼å¸ˆå‚¬äº†ï¼", "ä»Šæ™šé€šå®µå†™è®ºæ–‡ï¼"],
                    parent: isDeath ? ["å®¶é•¿ï¼šä¸‹æ¬¡è€ƒå¥½ç‚¹ï¼", "å®¶é•¿ï¼šåˆ«ç©æ¸¸æˆäº†ï¼"] : ["è€ƒä¸åˆ°Aä¸å‡†ç©æ‰‹æœºï¼", "ä½ æ˜¯ä¸æ˜¯åˆåœ¨ç©æ¸¸æˆï¼Ÿ", "æˆç»©å‡ºæ¥äº†ï¼Œå‡†å¤‡æŒ¨éª‚ï¼", "æ—©ç‚¹å›å®¶åƒé¥­ï¼"],
                    boss: isDeath ? ["è€æ¿ï¼šä½ ä»¬éƒ½å¾—åŠ ç­ï¼(æ¶ˆå¤±)", "è€æ¿ï¼šæˆ‘è¿˜ä¼šå›æ¥çš„ï¼"] : ["KPIè¿˜ä¸å¤Ÿï¼", "è¿™ä¸ªéœ€æ±‚æ˜å¤©ä¸Šçº¿ï¼", "ä»Šæ™šåŠ ç­ï¼", "Lunch break? No, got meeting!", "Aiyo, why so slow one?"],
                    coworker: isDeath ? ["åŒäº‹ï¼šç»ˆäºè§£è„±äº†...", "åŒäº‹ï¼šæˆ‘ä¸‹è¾ˆå­ä¸åšç å†œäº†ï¼"] : ["è¿™ä¸ªbugä¸æ˜¯æˆ‘å†™çš„ï¼", "åˆè¦å¼€ä¼šï¼Œæ•‘å‘½ï¼", "ä»Šæ™šåˆè¦åŠ ç­å’¯...", "ä½ åšå®Œäº†å—ï¼Ÿæˆ‘ç­‰ä½ merge PR~"],
                    hr: isDeath ? ["HRï¼šä¸‹æ¬¡å†æ¥é¢è¯•ï¼", "HRï¼šç¦åˆ©ç­‰ä¸‹å‘ï¼"] : ["äº”é™©ä¸€é‡‘äº†è§£ä¸€ä¸‹ï¼Ÿ", "è¯·å‡æµç¨‹èµ°ä¸€éã€‚", "ç»©æ•ˆè€ƒæ ¸è¦å¼€å§‹äº†ï¼", "ä¸‹ä¸ªæœˆè°ƒå²—ã€‚"],
                    client: isDeath ? ["ç”²æ–¹ï¼šä¸‹æ¬¡è¿˜è¦æ”¹ï¼", "ç”²æ–¹ï¼šé¢„ç®—ç ä¸€åŠï¼"] : ["è¿™ä¸ªéœ€æ±‚å†æ”¹ä¸€ä¸‹ã€‚", "æˆ‘ä»¬è¦åŠ æ–°åŠŸèƒ½ã€‚", "ä¸‹å‘¨ä¸Šçº¿å¯ä»¥å—ï¼Ÿ", "ä½ ä»¬å¾ˆgengå’§ï¼"],
                    ppt: isDeath ? ["PPTï¼šç»ˆäºä¸ç”¨æ”¹äº†ï¼", "PPTï¼šä¸‹æ¬¡è¿˜ä¼šæœ‰ï¼"] : ["PPTä»Šæ™šè¦äº¤ï¼", "å†ç¾åŒ–ä¸€ä¸‹ã€‚", "è€æ¿è¦åŠ¨ç”»ï¼", "å­—ä½“ç»Ÿä¸€æ²¡ï¼Ÿ"],
                    kpi: isDeath ? ["KPIï¼šä¸‹å­£åº¦è§ï¼", "KPIï¼šä½ ä»¥ä¸ºç»“æŸäº†å—ï¼Ÿ"] : ["KPIè¿˜å·®ä¸€ç‚¹ï¼", "ç›®æ ‡è¦ç¿»å€ï¼", "è€æ¿åœ¨çœ‹ä½ å“¦ï¼", "å†²ä¸šç»©å•¦ï¼"],
                    meeting: isDeath ? ["ä¼šè®®ï¼šç»ˆäºç»“æŸäº†ï¼", "ä¼šè®®ï¼šä¸‹æ¬¡å†çº¦ï¼"] : ["å¼€ä¼šæ—¶é—´åˆ°ï¼", "PPTå‡†å¤‡å¥½äº†å—ï¼Ÿ", "è€æ¿è¦å‘è¨€äº†ï¼", "åˆè¦å¤´è„‘é£æš´ï¼"],
                    desk: isDeath ? ["å·¥ä½ï¼šç»ˆäºå¯ä»¥ä¼‘æ¯äº†ï¼", "å·¥ä½ï¼šä¸‹æ¬¡è¿˜ä¼šæœ‰æ–°äººï¼"] : ["å·¥ä½æ€ä¹ˆåˆä¹±äº†ï¼Ÿ", "è®°å¾—æ‰“å¡ï¼", "ä»Šå¤©è°åæˆ‘æ—è¾¹ï¼Ÿ", "åˆä¼‘æ—¶é—´åˆ°ï¼"],
                    clock: isDeath ? ["è€ƒå‹¤æœºï¼šä¸‹æ¬¡åˆ«è¿Ÿåˆ°ï¼", "è€ƒå‹¤æœºï¼šæ‰“å¡å¤±è´¥ï¼"] : ["è®°å¾—æ‰“å¡ï¼", "è¿Ÿåˆ°è¦æ‰£é’±ï¼", "å·¥æ—¶ä¸å¤Ÿå“¦ï¼", "è€æ¿åœ¨çœ‹ç€ä½ ï¼"],
                    customer: isDeath ? ["å®¢æˆ·ï¼šä¸‹æ¬¡è¿˜æ‰¾ä½ ä»¬ï¼", "å®¢æˆ·ï¼šæœåŠ¡ä¸é”™ï¼"] : ["å®¢æˆ·è¦æ”¹éœ€æ±‚ï¼", "å®¢æˆ·è¦è§é¢ï¼", "å®¢æˆ·è¯´è¦ä¾¿å®œç‚¹ï¼", "å®¢æˆ·æ»¡æ„æœ€é‡è¦ï¼"],
                    mostHated: isDeath ? ["ä½ ç»ˆäº...è§£è„±äº†...", "æˆ‘è¿˜ä¼šå›æ¥çš„ï¼ä½ ç­‰ç€ï¼"] : ["ä½ ä¸ºä»€ä¹ˆè®¨åŒæˆ‘ï¼Ÿï¼", "æ¥å•Šï¼Œäº’ç›¸ä¼¤å®³å•Šï¼", "åˆ«ä»¥ä¸ºä½ èµ¢äº†ï¼", "æˆ‘å°±åœ¨è¿™é‡Œï¼Œæ¥æ‰“æˆ‘å•Šï¼", "Aduh, why you hate me so much?!"],
                    normal: isDeath ? ["æ¯ç­ï¼", "å†è§ä¸–ç•Œ...", "Game over lah!"] : ["å•Šï¼å¥½ç—›ï¼", "ä¸ºä»€ä¹ˆæ˜¯æˆ‘ï¼Ÿ", "æˆ‘è¿˜ä¼šå›æ¥çš„ï¼", "ä¸è¦å•Šï¼", "æ•‘å‘½ï¼", "æˆ‘æŠ•é™ï¼", "Aduh sakit lah!"]
                };
                const typeDialogs = dialogs[this.type] || dialogs.normal;
                const msg = typeDialogs[Math.floor(Math.random() * typeDialogs.length)];
                if (!this.dialogQueue) this.dialogQueue = [];
                this.dialogQueue.push({text: msg, timer: 3});
                if (this.dialogQueue.length > 3) this.dialogQueue.shift();
                this.dialogBubble = this.dialogQueue.map(d=>d.text).join('\n');
                this.dialogTimer = 3;
            }
        }

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        class Projectile {
            constructor(x, y, targetX, targetY, type = null, rageMultiplier = 1) {
                this.x = x;
                this.y = y;
                this.type = type || Projectile.randomType();
                this.setTypeProps();
                this.power *= rageMultiplier;
                this.rageMultiplier = rageMultiplier;
                const dx = targetX - x;
                const dy = targetY - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.velocity = {
                    x: (dx / distance) * this.speed,
                    y: (dy / distance) * this.speed
                };
                this.trail = [];
                this.life = 1;
            }
            
            static randomType() {
                const types = ['normal', 'fast', 'bouncy', 'zigzag'];
                return types[Math.floor(Math.random() * types.length)];
            }
            
            setTypeProps() {
                switch(this.type) {
                    case 'fast':
                        this.power = 30; this.speed = 25; this.size = 4; this.color = '#4ecdc4'; break;
                    case 'bouncy':
                        this.power = 40; this.speed = 10; this.size = 7; this.color = '#feca57'; break;
                    case 'zigzag':
                        this.power = 20; this.speed = 12; this.size = 5; this.color = '#6c5ce7'; this.zigzagAngle = 0; break;
                    default:
                        this.power = 50; this.speed = 15; this.size = 5; this.color = '#ff6b6b'; break;
                }
            }
            
            update() {
                if (this.type === 'zigzag') {
                    this.zigzagAngle += 0.3;
                    this.x += this.velocity.x + Math.sin(this.zigzagAngle) * 3;
                    this.y += this.velocity.y;
                } else {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                }
                this.life -= 0.01;
                this.trail.push({x: this.x, y: this.y, life: this.life});
                if (this.trail.length > 5) this.trail.shift();
                // Bouncyåå¼¹
                if (this.type === 'bouncy') {
                    if (this.x < this.size || this.x > canvas.width - this.size) this.velocity.x *= -1;
                    if (this.y < this.size || this.y > canvas.height - this.size) this.velocity.y *= -1;
                }
                // Check collision with targets
                gameState.targets.forEach((target, index) => {
                    const dx = this.x - target.x;
                    const dy = this.y - target.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < target.size + this.size) {
                        this.explode(target, index);
                    }
                });
                return this.life > 0 && this.x > -100 && this.x < canvas.width + 100 && this.y > -100 && this.y < canvas.height + 100;
            }
            
            explode(target, targetIndex) {
                const baseCount = 30;
                let comboMultiplier = 1 + Math.min(gameState.multiHitCount, 10) * 0.1;
                const count = Math.floor(baseCount * this.rageMultiplier * comboMultiplier);
                let death = false;
                if (target.health - this.power <= 0) death = true;
                for (let i = 0; i < (death ? count*2 : count); i++) {
                    gameState.particles.push({
                    x: this.x,
                    y: this.y,
                        velocity: {
                            x: (Math.random() - 0.5) * 28 * this.rageMultiplier * (death ? 1.5 : 1),
                            y: (Math.random() - 0.5) * 28 * this.rageMultiplier * (death ? 1.5 : 1)
                        },
                        size: Math.random() * (death ? 12 : 6) + 2,
                        color: death ? (Math.random() < 0.5 ? '#fff' : target.color) : target.color,
                        life: death ? 2 : 1.2
                    });
                }
                target.takeDamage(this.power);
                if (target.health <= 0) {
                    target.showDialog(true);
                    gameState.targets.splice(targetIndex, 1);
                    gameState.score += target.size * gameState.combo;
                    gameState.combo++;
                    screenShake();
                }
                this.life = 0;
                document.body.style.background = '#ff2222';
                setTimeout(()=>{document.body.style.background='';}, 60);
            }
            
            draw() {
                ctx.save();
                // æ‹–å°¾
                for(let i=this.trail.length-1;i>=0;i--){
                    const t = this.trail[i];
                    const p = i/this.trail.length;
                    ctx.globalAlpha = 0.18 + 0.22*p;
                        ctx.beginPath();
                    ctx.arc(t.x, t.y, this.size*1.2*(0.7+p), 0, Math.PI*2);
                    ctx.fillStyle = `rgba(255,30,30,${0.18+0.22*p})`;
                    ctx.shadowColor = p>0.7 ? '#ffe066' : '#ff6b6b';
                    ctx.shadowBlur = 16*p;
                    ctx.fill();
                }
                ctx.globalAlpha = 1;
                // ä¸»ä½“
                ctx.shadowColor = '#ff1e1e';
                ctx.shadowBlur = 32;
                ctx.fillStyle = '#ff2222';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size*1.18, 0, Math.PI*2);
                ctx.fill();
                // ç«ç„°è¾¹ç¼˜
                ctx.shadowColor = '#ffe066';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size*1.5, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,230,102,0.18)';
                ctx.fill();
                ctx.restore();
            }
        }
        
        function createTargetExplosion(target) {
            // Create massive explosion
            for (let i = 0; i < 50; i++) {
                gameState.particles.push({
                    x: target.x,
                    y: target.y,
                    velocity: {
                        x: (Math.random() - 0.5) * 30,
                        y: (Math.random() - 0.5) * 30
                    },
                    size: Math.random() * 8 + 3,
                    color: target.color,
                    life: 1.5
                });
            }
            // SLOW MOTION for big targets
            if (target.size > 50) {
                createSlowMotion(0.3, 1000); // 30%é€Ÿåº¦æŒç»­1ç§’
            }
            // Create shockwave
            gameState.explosions.push({
                x: target.x,
                y: target.y,
                size: 0,
                maxSize: target.size * 4,
                life: 2,
                shockwave: true
            });
        }
        
        function spawnNamedTarget() {
            const availableNames = targetNames;
            const name = availableNames[Math.floor(Math.random() * availableNames.length)];
            const suffixes = ['', ' Jr', ' II', ' III', ' Alpha', ' Beta', ' Prime', ' Ultra'];
            const randomSuffix = suffixes[Math.floor(Math.random() * suffixes.length)];
            const finalName = name + randomSuffix;
            // å¤šæ ·åŒ–é¢œè‰²
            const colorPalettes = [
                ['#ff6b6b', '#4ecdc4', '#45b7d1'],
                ['#feca57', '#ff9ff3', '#6c5ce7'],
                ['#00b894', '#fdcb6e', '#d63031'],
                ['#0984e3', '#fd79a8', '#00b894']
            ];
            const palette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
            const color = palette[Math.floor(Math.random() * palette.length)];
            const size = Math.random() * 40 + 30;
            const x = Math.random() * (canvas.width - size * 2) + size;
            const y = Math.random() * (canvas.height - size * 2) + size;
	    console.log('ç”Ÿæˆç›®æ ‡', {x, y, size, color, name});
            gameState.targets.push(new Target(x, y, size, color, finalName, {
                x: (Math.random() - 0.5) * 4,
                y: (Math.random() - 0.5) * 4
            }));
        }
        
        function spawnTargetWave() {
            const waveSize = Math.min(8, targetNames.length + 3); // Increased wave size and made it scale slightly with names
            for (let i = 0; i < waveSize; i++) {
                setTimeout(() => {
                    spawnNamedTarget();
                }, i * 40); // Slightly reduced delay for faster generation
            }
            showDestructionText('TARGET WAVE INCOMING!');
        }
        
        function createBlackHole() {
            gameState.blackHoles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: 30,
                maxSize: 80,
                growing: true,
                life: 10
            });
            showDestructionText('BLACK HOLE DEPLOYED!');
        }
        
        function triggerMegaBlast() {
            if (gameState.targets.length > 0) {
                const target = gameState.targets[Math.floor(Math.random() * gameState.targets.length)];
                gameState.explosions.push({
                    x: target.x,
                    y: target.y,
                    size: 0,
                    maxSize: 300,
                    life: 3,
                    megablast: true
                });
                showDestructionText('MEGA BLAST!');
                screenShake();
            }
        }
        
        function showDestructionText(text) {
            const element = document.createElement('div');
            element.className = 'destruction-text';
            element.textContent = text;
            document.body.appendChild(element);
            
            setTimeout(() => element.remove(), 2000);
        }
        
        function screenShake() {
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 500);
        }
        
        function updateGame() {
            // Update targets
            gameState.targets.forEach(target => target.update());
            
            // Update projectiles
            gameState.projectiles = gameState.projectiles.filter(projectile => projectile.update());
            
            // Update particles
            gameState.particles = gameState.particles.filter(particle => {
                particle.x += particle.velocity.x;
                particle.y += particle.velocity.y;
                particle.velocity.x *= 0.96;
                particle.velocity.y *= 0.96;
                particle.life -= 0.018;
                return particle.life > 0;
            });
            
            // Update explosions
            gameState.explosions = gameState.explosions.filter(explosion => {
                explosion.size += (explosion.maxSize - explosion.size) * 0.1;
                explosion.life -= 0.02;
                return explosion.life > 0;
            });
            
            // Update black holes
            gameState.blackHoles = gameState.blackHoles.filter(blackHole => {
                if (blackHole.growing && blackHole.size < blackHole.maxSize) {
                    blackHole.size += 2;
                } else {
                    blackHole.growing = false;
                    blackHole.life -= 0.01;
                }
                
                // Black hole gravity effect
                gameState.targets.forEach((target, index) => {
                    const dx = blackHole.x - target.x;
                    const dy = blackHole.y - target.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < blackHole.size) {
                        // Target consumed
                        showDestructionText(`${target.name.toUpperCase()} CONSUMED!`);
                        usedNames.push(target.name);
                        gameState.targets.splice(index, 1);
                        gameState.score += 500;
                        screenShake();
                    } else if (distance < blackHole.size * 3) {
                        // Gravitational pull
                        const force = blackHole.size / distance * 0.5;
                        target.velocity.x += (dx / distance) * force;
                        target.velocity.y += (dy / distance) * force;
                    }
                });
                
                return blackHole.life > 0;
            });
            
            // å¢åŠ ç›®æ ‡ç”Ÿæˆé¢‘ç‡ï¼Œå¹¶ç§»é™¤æ•°é‡é™åˆ¶
            if (Math.random() < 0.01 && gameState.targets.length < 20) { // æé«˜ç”Ÿæˆæ¦‚ç‡ï¼Œå¢åŠ æœ€å¤§ç›®æ ‡æ•°
                spawnNamedTarget();
            }
            
            // æ›´æ–°å¤ªç©ºåƒåœ¾
            gameState.spaceDebris = gameState.spaceDebris.filter(debris => {
                debris.update();
                return true;
            });

            // éšæœºç”Ÿæˆå¤ªç©ºåƒåœ¾
            if (Math.random() < 0.005) {
                gameState.spaceDebris.push(new SpaceDebris(
                    Math.random() * canvas.width,
                    Math.random() * canvas.height
                ));
            }

            // éšæœºç”ŸæˆUFO
            if (Math.random() < 0.001) {
                gameState.ufos.push(new UFO());
            }
            
            if (gameState.multiHitTimer > 0) {
                gameState.multiHitTimer -= 0.016;
                if (gameState.multiHitTimer <= 0) {
                    gameState.multiHitCount = 0;
                    document.getElementById('multiHitCounter').style.display = 'none';
                }
            }
            
            // æ„¤æ€’æ¨¡å¼å€’è®¡æ—¶
            if (gameState.isRageMode) {
                gameState.rageModeTimer -= 0.016;
                if (gameState.rageModeTimer <= 0) {
                    gameState.isRageMode = false;
                    document.body.classList.remove('red-rage');
                    const btn = document.getElementById('rageBtn');
                    btn.disabled = false;
                    btn.textContent = 'ğŸ˜¡ æ„¤æ€’æ¨¡å¼';
                }
            }
            // æœºå…³æªæ¨¡å¼å€’è®¡æ—¶
            if (gameState.isGunMode) {
                gameState.gunModeTimer -= 0.016;
                if (gameState.gunModeTimer <= 0) {
                    gameState.isGunMode = false;
                    const btn = document.getElementById('gunBtn');
                    btn.disabled = false;
                    btn.textContent = 'ğŸ”« æœºå…³æªæ¨¡å¼';
                } else {
                    // è‡ªåŠ¨å‘å°„
                    gameState.gunModeFireCD -= 0.016;
                    if (gameState.gunModeFireCD <= 0) {
                        for(let i=0;i<3;i++){
                          const angle = Math.random()*Math.PI*2;
                          const dist = 80+Math.random()*60;
                          const tx = gameState.mouseX + Math.cos(angle)*dist;
                          const ty = gameState.mouseY + Math.sin(angle)*dist;
                          fireProjectile(tx, ty, gameState.isRageMode);
                        }
                        gameState.gunModeFireCD = 0.08;
                    }
                }
            }
            
            if (gameState.multiHitCount >= 3) {
                const counter = document.getElementById('multiHitCounter');
                counter.style.animation = 'flashCombo 0.5s infinite alternate';
                counter.style.fontSize = '28px';
            } else {
                const counter = document.getElementById('multiHitCounter');
                counter.style.animation = '';
                counter.style.fontSize = '18px';
            }
            
            updateHUD();
        }
        
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            gameState.stars.forEach(star => {
                star.twinkle += 0.1;
                const alpha = (Math.sin(star.twinkle) + 1) * 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw targets
            gameState.targets.forEach(target => target.draw());
            
            // Draw projectiles
            gameState.projectiles.forEach(projectile => projectile.draw());
            
            // Draw particles
            for (const particle of gameState.particles) {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw explosions
            gameState.explosions.forEach(explosion => {
                const alpha = explosion.life;
                if (explosion.megablast) {
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = 10;
                } else if (explosion.shockwave) {
                    ctx.strokeStyle = `rgba(255, 107, 107, ${alpha * 0.5})`;
                    ctx.lineWidth = 5;
                } else {
                    ctx.fillStyle = `rgba(255, 165, 0, ${alpha * 0.3})`;
                }
                
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
                if (explosion.megablast || explosion.shockwave) {
                    ctx.stroke();
                } else {
                    ctx.fill();
                }
            });
            
            // Draw black holes
            gameState.blackHoles.forEach(blackHole => {
                // Event horizon
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(blackHole.x, blackHole.y, blackHole.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Accretion disk
                for (let i = 0; i < 3; i++) {
                    ctx.strokeStyle = `rgba(255, 165, 0, ${0.3 - i * 0.1})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(blackHole.x, blackHole.y, blackHole.size + i * 20, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // ç»˜åˆ¶å¤ªç©ºåƒåœ¾
            gameState.spaceDebris.forEach(debris => debris.draw());

            // ç»˜åˆ¶UFO
            gameState.ufos.forEach(ufo => ufo.draw());
        }
        
        function updateHUD() {
            document.getElementById('score').textContent = `ğŸŒŸ DESTRUCTION SCORE: ${gameState.score.toLocaleString()}`;
            document.getElementById('combo').textContent = `ğŸ’¥ COMBO: x${gameState.combo}`;
            document.getElementById('targets').textContent = `ğŸ¯ TARGETS: ${gameState.targets.length}`;
            document.getElementById('rageFill').style.height = `${gameState.rage}%`;
            document.getElementById('rageFill').style.background = `linear-gradient(to top, #ff6b6b, #ff4757, #ff3838, #ff1e1e${gameState.rage > 80 ? ', #ff0000' : ''})`;
        }
        
        function resetSimulation() {
            gameState.targets = [];
            gameState.projectiles = [];
            gameState.particles = [];
            gameState.blackHoles = [];
            gameState.explosions = [];
            gameState.score = 0;
            gameState.combo = 1;
            // ç§»é™¤ usedNames é‡ç½®
            // ç”Ÿæˆæ›´å¤šåˆå§‹ç›®æ ‡
            for (let i = 0; i < Math.min(10, targetNames.length); i++) {
                spawnNamedTarget();
            }
            showDestructionText('SIMULATION RESET!');
        }
        
        // --- MOUSE & INPUT HANDLING ---

        // Update crosshair position
        function updateCrosshair(e) {
            const crosshair = document.getElementById('crosshair');
            let x, y;
            if (e.touches && e.touches.length > 0) {
                x = e.touches[0].clientX;
                y = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) {
                x = e.changedTouches[0].clientX;
                y = e.changedTouches[0].clientY;
            } else if (e) {
                x = e.clientX;
                y = e.clientY;
            }
            gameState.mouseX = x;
            gameState.mouseY = y;
            crosshair.style.left = x + 'px';
            crosshair.style.top = y + 'px';
        }

        document.addEventListener('mousemove', updateCrosshair);
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameState.isPlaying) return;
            updateCrosshair(e);
            gameState.isFiring = true;
            if (gameState.fireInterval) clearInterval(gameState.fireInterval); // Clear any existing interval
            gameState.fireInterval = setInterval(() => {
                if (gameState.isFiring) {
                    fireProjectile(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, 100); // Fire every 100ms
        });
        canvas.addEventListener('touchend', (e) => {
            if (!gameState.isPlaying) return;
            gameState.isFiring = false;
            if (gameState.fireInterval) {
                clearInterval(gameState.fireInterval);
                gameState.fireInterval = null;
            }
        });

        // Charging and firing logic
        canvas.addEventListener('mousedown', (e) => {
            if (!gameState.isPlaying) return;
            // ç›´æ¥å‘å°„ï¼Œä¸éœ€è¦è“„åŠ›
            fireProjectile(gameState.mouseX, gameState.mouseY);
        });

        function fireProjectile(x, y, isRage) {
            let rageMultiplier = 1 + gameState.rage / 100;
            if (gameState.isRageMode || isRage) rageMultiplier = 2;
            // æ„¤æ€’æ¨¡å¼ä¸‹å¤šå‘ä¸€é¢—
            if (gameState.isRageMode || isRage) {
                gameState.projectiles.push(new Projectile(canvas.width / 2, canvas.height, x, y, null, rageMultiplier));
                // é¢å¤–ä¸€é¢—ç¨å¾®åç§»
                const dx = x - canvas.width/2, dy = y - canvas.height;
                const angle = Math.atan2(dy, dx) + 0.12;
                const tx2 = canvas.width/2 + Math.cos(angle)*Math.sqrt(dx*dx+dy*dy);
                const ty2 = canvas.height + Math.sin(angle)*Math.sqrt(dx*dx+dy*dy);
                gameState.projectiles.push(new Projectile(canvas.width / 2, canvas.height, tx2, ty2, null, rageMultiplier));
            } else {
                gameState.projectiles.push(new Projectile(canvas.width / 2, canvas.height, x, y, null, rageMultiplier));
            }
        }

        // Resize canvas on window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Re-initialize stars to fill new space
            if (gameState.isPlaying) {
                gameState.stars = [];
                for (let i = 0; i < 200; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 2 + 0.5,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            }
        });

        // Set initial crosshair position
        updateCrosshair({clientX: window.innerWidth / 2, clientY: window.innerHeight / 2});

        // Optional: allow pressing Enter to start game
        const nameInput = document.getElementById('nameInput');
        nameInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                startGame();
            }
        });

        function gameLoop() {
            if (!gameState.isPlaying) return;
            updateGame();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        // æ·»åŠ å¤ªç©ºåƒåœ¾ç±»
        class SpaceDebris {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 20 + 10;
                this.rotation = Math.random() * Math.PI * 2;
                this.velocity = {
                    x: (Math.random() - 0.5) * 2,
                    y: (Math.random() - 0.5) * 2
                };
                this.points = Math.floor(Math.random() * 3) + 1;
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.rotation += 0.02;

                // è¾¹ç•Œæ£€æŸ¥
                if (this.x < -this.size) this.x = canvas.width + this.size;
                if (this.x > canvas.width + this.size) this.x = -this.size;
                if (this.y < -this.size) this.y = canvas.height + this.size;
                if (this.y > canvas.height + this.size) this.y = -this.size;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // ç»˜åˆ¶å¤ªç©ºåƒåœ¾
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(-this.size, -this.size);
                ctx.lineTo(this.size, -this.size);
                ctx.lineTo(this.size/2, this.size);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        // æ·»åŠ UFOç±»
        class UFO {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = -50;
                this.size = 40;
                this.velocity = {
                    x: (Math.random() - 0.5) * 3,
                    y: 1
                };
                this.power = Math.random() < 0.5 ? 'shield' : 'speed';
            }

            update() {
                this.x += this.velocity.x;
                this.y += this.velocity.y;

                if (this.y > canvas.height + 50) {
                    return false;
                }
                return true;
            }

            draw() {
                // ç»˜åˆ¶UFO
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.size, this.size/2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶å…‰æ•ˆ
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + this.size/2, this.size/2, this.size/4, 0, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // æ–°å‡½æ•°ï¼šæ…¢åŠ¨ä½œ
        function createSlowMotion(speed, duration) {
            document.body.classList.add('slow-motion');
            document.body.style.setProperty('--slow-speed', speed);
            setTimeout(() => {
                document.body.classList.remove('slow-motion');
            }, duration);
        }

        // æŒ‰é’®äº‹ä»¶ç›‘å¬
        window.addEventListener('DOMContentLoaded',()=>{
          document.getElementById('rageBtn').onclick = function() {
            if (!gameState.isRageMode && gameState.rage >= 100) {
              gameState.isRageMode = true;
              gameState.rageModeTimer = 15;
              document.body.classList.add('red-rage');
              this.disabled = true;
              this.textContent = 'ğŸ˜¡ æ„¤æ€’ä¸­...';
              gameState.rage = 0;
              document.getElementById('rageFill').style.height = '0%';
            }
          };
          document.getElementById('gunBtn').onclick = function() {
            if (!gameState.isGunMode) {
              gameState.isGunMode = true;
              gameState.gunModeTimer = 10;
              this.disabled = true;
              this.textContent = 'ğŸ”« æ‰«å°„ä¸­...';
            }
          };
        });

        // 5. å¢å¼ºäº¤äº’æ–¹å¼
        // å³é”®=æ•£å¼¹ï¼ŒåŒå‡»=è¶…çº§çˆ†ç‚¸ï¼Œæ™®é€šç‚¹å‡»=åŸºç¡€æ”»å‡»
        canvas.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            if (!gameState.isPlaying) return;
            // æ•£å¼¹ï¼š5é¢—å­å¼¹ï¼Œè§’åº¦åˆ†æ•£
            const baseAngle = Math.atan2(gameState.mouseY - canvas.height, gameState.mouseX - canvas.width/2);
            for (let i = -2; i <= 2; i++) {
                const angle = baseAngle + i * 0.18;
                const dist = 400;
                const tx = canvas.width/2 + Math.cos(angle)*dist;
                const ty = canvas.height + Math.sin(angle)*dist;
                fireProjectile(tx, ty);
            }
        });
        /*
        canvas.addEventListener('dblclick', function(e) {
            if (!gameState.isPlaying) return;
            // è¶…çº§çˆ†ç‚¸ï¼šåœ¨é¼ æ ‡å¤„ç”Ÿæˆå¤§çˆ†ç‚¸
            gameState.explosions.push({
                x: gameState.mouseX,
                y: gameState.mouseY,
                size: 0,
                maxSize: 400,
                life: 2,
                megablast: true
            });
            showDestructionText('è¶…çº§çˆ†ç‚¸!');
            screenShake();
        });
        */

        // äº¤äº’é€»è¾‘ï¼šé€‰æ‹©èº«ä»½ååŠ¨æ€æ¸²æŸ“å¯¹æ‰‹ç±»å‹æŒ‰é’®ï¼Œä¸‹ä¸€æ­¥åæ‰æ˜¾ç¤ºåå­—
        window.addEventListener('DOMContentLoaded',()=>{
          const playerTypeSelect = document.getElementById('playerTypeSelect');
          const opponentSelect = document.getElementById('opponentSelect');
          const nameInput = document.getElementById('nameInput');
          const startBtn = document.getElementById('startGame');
          const guide = document.getElementById('gameGuide');
          const nameInputTip = document.getElementById('nameInputTip');
          const opponentBtns = document.getElementById('opponentBtns');
          const nextBtn = document.getElementById('opponentNext');
          nameInput.style.display = 'none';
          startBtn.style.display = 'none';
          guide.style.display = 'none';
          nameInputTip.style.display = 'none';
          opponentSelect.style.display = 'none';
          window.selectedOpponentTypes = [];
          window.selectedPlayerType = null;
          // èº«ä»½é€‰æ‹©
          playerTypeSelect.querySelectorAll('button').forEach(btn=>{
            btn.onclick = function(){
              window.selectedPlayerType = this.getAttribute('data-player');
              playerTypeSelect.style.display = 'none';
              opponentSelect.style.display = 'block';
              // æ¸²æŸ“å¯¹åº”å¯¹æ‰‹ç±»å‹
              let types = [];
              if(window.selectedPlayerType==='student'){
                types = [
                  {type:'teacher',label:'è€å¸ˆ'},
                  {type:'homework',label:'ä½œä¸š'},
                  {type:'parent',label:'å®¶é•¿'},
                  {type:'mostHated',label:'ä½ æœ€è®¨åŒçš„å¯¹è±¡æ˜¯è°?'}
                ];
              }else{
                types = [
                  {type:'boss',label:'è€æ¿'},
                  {type:'hr',label:'HR'},
                  {type:'meeting',label:'ä¼šè®®'},
                  {type:'mostHated',label:'ä½ æœ€è®¨åŒçš„å¯¹è±¡æ˜¯è°?'}
                ];
              }
              opponentBtns.innerHTML = types.map(t=>`<button class='control-btn' data-type='${t.type}'>${t.label}</button>`).join('');
              window.selectedOpponentTypes = [];
              opponentBtns.querySelectorAll('button').forEach(btn=>{
                btn.onclick = function(){
                  const type = this.getAttribute('data-type');
                  if(window.selectedOpponentTypes.includes(type)){
                    window.selectedOpponentTypes = window.selectedOpponentTypes.filter(t=>t!==type);
                    this.classList.remove('selected');
                  }else{
                    window.selectedOpponentTypes.push(type);
                    this.classList.add('selected');
                  }
                };
              });
            };
          });
          // ä¸‹ä¸€æ­¥
          nextBtn.onclick = function(){
            if(window.selectedOpponentTypes.length===0){
              alert('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå¯¹æ‰‹ç±»å‹ï¼');
              return;
            }
            opponentSelect.style.display = 'none';
            nameInput.style.display = 'block';
            startBtn.style.display = 'inline-block';
            guide.style.display = 'block';
            nameInputTip.style.display = 'block';
            const typeNames = window.selectedOpponentTypes.map(t=>{
              const map = {
                teacher:'è€å¸ˆ',topstudent:'å­¦éœ¸',homework:'ä½œä¸š',exam:'è€ƒè¯•',paper:'è®ºæ–‡',parent:'å®¶é•¿',
                boss:'è€æ¿',coworker:'åŒäº‹',hr:'HR',client:'ç”²æ–¹',ppt:'PPT',kpi:'KPI',meeting:'ä¼šè®®',desk:'å·¥ä½',clock:'è€ƒå‹¤æœº',customer:'å®¢æˆ·',
                mostHated:'ä½ æœ€è®¨åŒçš„å¯¹è±¡'
              };
              return map[t]||t;
            });
            nameInput.placeholder = `è¯·è¾“å…¥${typeNames.join('ã€')}çš„åå­—ï¼Œæ¯è¡Œä¸€ä¸ª...`;
          };
        });
    </script>
</body>
</html>
